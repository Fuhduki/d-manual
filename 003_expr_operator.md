# 式と演算子

## 式と演算子

ここからは式のお話をします。
式は、D言語での計算の一番小さな単位です。
たとえば、`1 + 2 + 3`は式ですが、この式に含まれる`1 + 2`, `1`, `2`, `3`も同様に式です。
`1`や`2`, `3`などはリテラル(Literal)と呼ばれると先ほど説明しましたね。
式は演算子などによって、より大きな式を作ります。

式は評価されると値を持ちます。
たとえば`1`ならint型の`1`、`int a = 12;`として`a + 2`の式を評価するとint型の`14`という値になります。
`a + b`の`a`と`b`の評価は同時に行われるわけではなく、`a`が先に評価され、次に`b`が評価されます。
この評価順序は演算子によって異なりますが、2項演算子であれば左が優先されます。
ちなみに、この評価順序はそれほど重要ではありませんし、クリティカルな問題にもなりません。
2項演算子は左優先ということ以外、覚えている人や知っている人は私を含めてほぼ皆無であると思います。
(a[b]という演算子は、bを評価した後にaを評価します。関数呼び出しのa(b)は逆にaを評価してbを評価します。)
(要出典, コンパイラの実装によっては異なっても良い？)

また、演算子にはそれぞれ結合規則が定められています。
たとえば、`1.0 / 2 / 5`は`(1.0 / 2) / 5`となってdouble型の`2.5`と評価されます。
もし、`1.0 / (2 / 5)`と解釈されるなら、`2 / 5`は整数である`int`型なので、`0`と評価され、結果的に`1.0 / 0`となります。
これが、評価されると`double.inf`という値になります。
つまり、演算子の結合の方向が右なのか左なのかによって式の値は異なるので、演算子ごとに結合の向きを定義しておく必要があります。

最後に、演算子には優先度という順位があります。
先に紹介した割り算の例では、式中に現れる演算子の優先順位がすべて同じであったため、結合規則に則って評価されました。
では、`1 + 4 / 2`という式があった場合にはどうすべきでしょうか？
掛け算や割り算は、足し算や引き算よりも先に計算することを小学校の算数で勉強したと思います。
D言語でも(大体のプログラミング言語でも)同じ規則が成り立ちます。
この場合には、`1 + 4`よりも先に`4 / 2`が評価されて、`1 + 2`となり、最終的に`3`と評価されます。

プログラマはこれらの評価の順序を覚えているかというと、正確に把握できている人は少ないと思います。
ですから、`1 + 4 / 2`や`1.0 / 2 / 5`などという明らかな場合はいいのですが、複雑な場合には、カッコ`()`で式をくくりましょう。
数学と同じように、`()`でくくればその中の優先順位は最も高くなります。
`(1 + 4) / 2`なら曖昧性が一切ありません。
しかし、残念ながらソースコードでは、中括弧`{}`や大括弧`[]`は、このような目的で使えません。


## 演算子と暗黙の数値型変換

数値型はたくさんありますが、それ故に異なる型との演算がよくあります。
この項では、たとえば`float + int`のような異なる数値型同士の演算の型について説明します。

数値型の演算子の規則は、簡単に言えば「大きい型や浮動小数点型に変換される可能性がある」です。
たとえば、`float + int`はどちらも`float + float`になって`float`になります。
以下に様々な例を示します。

writeTypeはよくわからないと思いますが、2つの型で22項演算してみた結果の型を出力する関数です。

````d
import std.stdio;

void writeType(T, string op, U)()
{
    writeln(typeof(mixin("T.init " ~ op ~ " U.init")).stringof);
}

void main()
{
    writeType!(   byte, "+",    byte)();    // int
    writeType!(   byte, "+",   ubyte)();    // int
    writeType!(  ubyte, "+",   ubyte)();    // int
    
    writeln();
    
    writeType!(  short, "+",   short)();    // int
    writeType!(  short, "+",  ushort)();    // int
    writeType!( ushort, "+",  ushort)();    // int

    writeln();

    writeType!(    int, "+",     int)();    //  int
    writeType!(    int, "+",    uint)();    // uint
    writeType!(   uint, "+",    uint)();    // uint

    writeln();

    writeType!(   long, "+",    long)();    //  long
    writeType!(   long, "+",   ulong)();    // ulong
    writeType!(  ulong, "+",   ulong)();    // ulong

    writeln();

    writeType!(    int, "+",    long)();    //  long
    writeType!(    int, "+",   ulong)();    // ulong
    writeType!(   uint, "+",    long)();    //  long
    writeType!(   uint, "+",   ulong)();    // ulong

    writeln();

    writeType!(  float, "+",   float)();    //  float
    writeType!(  float, "+",  ifloat)();    // cfloat
    writeType!( ifloat, "+",  ifloat)();    // ifloat

    writeln();

    writeType!(   real, "+",   float)();    //  real
    writeType!(   real, "+",  ifloat)();    // creal
    writeType!(  ireal, "+",  ifloat)();    // ireal

    writeln();

    writeType!(  float, "+",  cfloat)();    // cfloat
    writeType!( ifloat, "+",  cfloat)();    // cfloat
    writeType!( cfloat, "+",  cfloat)();    // cfloat

    writeln();

    writeType!( ifloat, "*",  ifloat)();    // float

    writeln();

    writeType!(   long, "+",   float)();    //  float
    writeType!(   long, "+",  ifloat)();    // cfloat
}
````

例をよく見ると、intより小さな整数型では、全てint型になっています。
int型以上の大きさの整数型では、より大きな型になります。
もう少しintやlongを詳しく見ると、頭に`u`がついた符号なし整数の方が強いことがわかります。

浮動小数点型では、実数型と実数型の和はもちろん実数型、実数型と虚数型の和は複素数型、虚数型同士の和は虚数型というように理に適っています。
また、複素数型に実数型や虚数型, 複素数型を足しても結果は複素数型です。
しかし、虚数型同士の積は実数型となり、数学で習ったことと一致すると思います。

整数型と浮動小数点型では、浮動小数点型のほうが強く、浮動小数点型になります。

以上のことを踏まえると、以下の様な規則に従っていることがわかります。

* 規則1: 数値型の暗黙変換のルール

1. 整数型から、より大きいサイズの整数型へは暗黙変換可能
2. 浮動小数点型から、より大きいサイズの浮動小数点型へは暗黙変換可能
3. 任意の整数型は、任意の実数浮動小数点型に暗黙変換可能

* 規則2: 演算子について、以下の規則は番号の小さいものから適応される。

1. どちらか片方が複素数型(浮動小数点型)である。
    そのうち最大の型にどちらの項も暗黙変換され、結果はその型となる。

2. どちらも虚数型(浮動小数点型)であり、積, 商の演算子である。
    そのうち最大の型にどちらの項も暗黙変換され、結果はその大きさの実数型となる。

3. どちらも虚数型(浮動小数点型)であり、和, 差の演算子である。
    そのうち最大の型にどちらの項も暗黙変換され、結果はその大きさの虚数型となる。

4. どちらか片方が虚数型(浮動小数点型)である。
    そのうち最大の型にどちらの項も暗黙変換され、結果はその大きさの複素型となる。

5. どちらか片方が浮動小数点型である。
    そのうち最大の型にどちらの項も暗黙変換され、結果はその大きさの浮動小数点型となる。

6. どちらか片方がulong型である。
    もう片方もulong型に暗黙変換され、結果もulong型。

7. どちらか片方がlong型である。
    もう片方もlong型に暗黙変換され、結果もlong型。

8. どちらか片方がuint型である。
    もう片方もuint型に暗黙変換され、結果もuint型。

9. その他の整数同士の演算
    両方ともint型に暗黙変換され、結果もint型。

規則2はややこしいかもしれませんが、複素数や虚数が式に現れなければ、5～9のみを意識すればよく、それらの基礎は規則1に従っているので理解しやすいと思います。


## 数値型に対する演算子

D言語の数値型には、大きく分けると整数型と浮動小数点型があることを説明しました。
ここでは、その数値型で使える演算子について説明して行きたいと思います。
説明で特に記述がない限り、全ての数値型で使用可能です。


### カッコ

~~~~d
int a = (1 + 2) / 1;
double d = (1.0 * 3) / 4.5;
~~~~

カッコは最も優先される演算子で、優先順位は1となっています。


### 単項プラス, 単項マイナス

~~~~d
int a = 12;

writeln(+a);    //  12
writeln(-a);    // -12

double d = 12;
writeln(+d);    //  12
writeln(-d);    // -12

cdouble c = 2 + 2i;
writeln(+c);    //  2+2i
writeln(-c);    // -2+-2i
~~~~

単項マイナス演算子は、符号を反転させるときに使用します。
単項プラス演算子は、ソースコードを見やすくするためだけにあります。
この2つの演算子は、優先順位3となっています。


### インクリメント, デクリメント

~~~~d
int a = 12;

writeln(++a);   // 13 前置インクリメント
writeln(a);     // 13

writeln(a++);   // 13 後置インクリメント
writeln(a);     // 14

writeln(--a);   // 13 前置デクリメント
writeln(a);     // 13

writeln(a--);   // 13 後置デクリメント
writeln(a);     // 12
~~~~

インクリメント(increment)とは、値を一つ増やすことです。
デクリメント(decrement)は逆に値を一つ減らします。
インクリメントもデクリメントも、左辺値(lvalue)でないと使えません。
左辺値というのはまだ説明していませんが、つまり、`++1`や`++(a + 3)`というのは出来ないということです。
理由は簡単で、そのように書いても加算された結果を格納できないからです。

インクリメントとデクリメントには、前置と後置があります。
前置の方を先に説明すると、「値を`1`だけ{増やして/減らして}から、評価する」となります。
つまり、`++a`は「`a`の値を`1`増やしてから、`a`を評価する」ということです。

後置インクリメントや後置デクリメントは、「`a`を評価した値を記憶しつつ、`a`の値を`1`だけ増やし、先ほど記憶した値を結果とする」という演算子です。

前置形式と後置形式で決定的に違うのがもう一つあります。
それは、「前置形式は左辺値を返すのに対して、後置形式は右辺値を返す」ことです。
左辺値は「`=`の左側に置ける値」で、右辺値は「`=`の右側に置ける値」でした。
インクリメントとデクリメントは左辺値に対して作用するので、後置形式の結果をインクリメントやデクリメントすることはできません。
逆に前置形式の結果はインクリメント,デクリメント可能です。

````d
float a = 1;

writeln(++(++a));   // OK
writeln((++a)++);   // OK
++a = 12;           // OK

writeln((a++)++);   // NG; Error: a++ is not an lvalue
writeln(++(a++));   // NG; Error: a++ is not an lvalue
a++ = 20;           // NG; Error: a++ is not an lvalue
````

ちなみに、前置形式と後置形式では後置形式の方が優先順位が高くなっています。
前置形式は優先順位3であるのに対して、後置形式は2です。

````d
cfloat c = 1 + 1i;

writeln(++c);       // 2+1i

writeln(++c++);     // NG; Error: c++ is not an lvalue
                    // ++(c++)と解釈されるため

writeln((++c)++);   // OK
````


### 否定

~~~~d
bool b = true;

writeln(!b);    // false
writeln(!!b);   // true

int a = 12;
writeln(!a);    // false
writeln(!!a);   // true
~~~~

3

### 補数

3

### 加算, 減算

加算と減算は特に言うことは無いと思います。
加算の演算子`+`と、減算の演算子`-`の優先順位と結合規則は同じで、優先順位6の左→右への結合規則です。
2項演算子なので、左辺を先に評価します。

~~~~d
int a = 1,
    b = 2;

writeln(a + b);     // 3
writeln(a - b);     // -1

int c = 3;

writeln(a + b + c); // (a + b) + c と解釈
writeln(a - b + c); // (a - b) + c と解釈
~~~~


### 乗算, 除算

乗算や除算は優先順位が5と、加算や減算よりも優先されるようになっています。
結合規則は、左→右です。
また、この2つも2項演算子なので、左辺を先に評価します。

~~~~d
int a = 1,
    b = 2;

writeln(a * b);     // 2
writeln(a / b);     // 0

int c = 3;

writeln(a * b * c); // (a * b) * c と解釈
writeln(a / b * c); // (a / b) * c と解釈
~~~~


### 剰余

~~~~d
writeln(10 % 3);    // 1; 10 / 3 = 3 .. 1
writeln(12 % 3);    // 0; 12 / 3 = 3 .. 0

writeln(-10 %  3);  // -1; -10 /  3 = -3 .. -1
writeln(-10 % -3);  // -1; -10 / -3 =  3 .. -1
writeln( 10 % -3);  //  1;  10 / -3 = -3 ..  1

writeln(11.6 % 3);  // 2.6; 11.6 / 3   = 3 .. 2.6
writeln(11.6 % 3.5);// 1.1; 11.6 / 3.5 = 3 .. 1.1

writeln(3 % 0.6);   // 0.6(誤差があるため)
~~~~

剰余演算子は、割り算での余りに相当します。
最後の例のように、浮動小数点数の演算では丸め誤差が存在するため、思った答えと違うものが出る可能性があります。
ほとんど整数でしか使用しないので気にはなりませんが、浮動小数点に対して使用する場合には注意が必要です。

優先順位は積や商と同じ5で、結合規則も同じ右→左です。


### 累乗

~~~~d
writeln()
~~~~

### ビット演算

10

### シフト演算

7

### 同値テスト(==), 非同値テスト(!=)

9

### 比較

9


### 論理演算子

and 11
or 12
条件 13

### 代入演算子, 複合代入演算子

14


### コンマ演算子

15


### 条件演算子


## 問題

## おわりに

## キーワード

* 評価(Evaluation)
* 暗黙の型変換(Implicit)
* 演算子(Operator)
* 演算子の優先順位(Priority of Operators, Order of Operators)
* 演算子の結合規則(Operator Associativity)