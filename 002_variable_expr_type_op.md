# 変数と式と型と演算子

## 式と文とは？

D言語のプログラムが関数とデータの集合であることは前の記事で説明しました。
では、関数は何の集合でできているかというと、文(statement)の集合です。
文は文で構成されたり、式(expression)で構成されます。
たとえば、`writeln("Hello, World!")`は式ですが、`;`を付けることで`writeln("Hello, World!");`となり文となります。
`"Hello, World!"`も式ですし、`123`も式です。
そして、 `void main(){}`というのも実際には宣言文(Declaration Statement)ですし、`import std.stdio;`もインポート宣言(Import Declaration)という文です。
ということで、D言語のプログラムは文の集合だったりします。


## 変数(Variable)

電卓にはメモリー機能というのがありますね。
使ったことがないなら、これからは使ってみることをオススメします、便利ですよ。
さて、プログラムでもメモリー機能が使えます。
それが変数です。
式の値は変数に格納しておくことができます。
また、変数は電卓のメモリ機能と違い、宣言しないと使えませんが、たくさん使用することが可能です。

````d
///src.d
import std.stdio;

void main()
{
    int a = 1 + 2;
    writeln(a);

    a = 3 + 1;
    writeln(a);

    a = a + 2;
    writeln(a);
}
````

````
$ rdmd src.d
3
4
6
````

変数は宣言した場所以降から有効になります。
例では、`int a = 1 + 2;`というのが変数の宣言の部分で、`int`型の変数`a`を宣言しています。
次の行の`writeln(a);`では`a`の値である`3`を表示します。
また、`a`は宣言したあとは自由に書き換えられます。
`=`は代入演算子で、右辺(rhs)の値を左辺(lhs)にセットします。
3つめの`a = a + 2;`は奇妙かもしれませんが、`a + 2`が6ですから`a = 6;`と同じです。


### 変数の宣言(Declaration)

変数の宣言は`Type identifier;`、もしくは初期化する場合は`Type identifier = initializer;`となります。
また、一度に複数宣言することもできて、`T a, b, c;`と書いたり、初期化したい場合には、

~~~~d
int a = 12,
    b = a + 1,
    c = a + b,
    d;
~~~~

という風にも書けます。

初期化の話が出ましたが、D言語では変数は宣言されたら自動的に初期化されます。
この初期化される値をデフォルト初期化値(デフォルト値, デフォルト初期化子; Default Initializer)


### 変数の寿命とスコープ

変数には寿命があり、そのスコープ内でのみ有効です。
ここでいうスコープとは、静的スコープ(Static Scope)や構文スコープ(Lexical Scope)と呼ばれるもののことです。
簡単にいうと、`{`から、それに対応する`}`までがスコープになります。
特に、最も外のスコープであるスコープはグローバルスコープ(Global Scope)と呼ばれます。

スコープは`{}`などによってネスト(nest; 入れ子状態のこと)されます。
宣言された変数などをシンボル(Symbol)と呼びますが、外側のスコープから内側のスコープのシンボルを覗くことはできません。
しかし、内側のスコープから外側のスコープのシンボルを覗くことは可能です。
ですので、外側のスコープで宣言されたシンボルと同じ名称のシンボルを内側のスコープで宣言できません。

例外は2つあり、1つ目は、グローバルなシンボルと同じ名称のシンボルを、より内側のスコープで宣言することは可能です。
この場合、`.<symbol>`というように書くことで、グローバルなシンボルを指すことができます。

2つ目はまだ説明していない内容も含まれるので今回は無視していただいても構いません。
未説明なことを承知で言うと、ユーザー定義型のスコープではグローバルでない外側のシンボルを上書きできます。
こちらのケースでは、上書きされた外側のシンボルにアクセスできなくなります。
(全てのパターンで完全に消えるわけではありません。あくまでも、`<symbol>`の形式でアクセスできなくなるということです。)

~~~~d
import std.stdio;

// ここはグローバルスコープ

int a = 0;

void main()
{
    // ここはmain関数のスコープ

    double a = 1;       // グローバルなシンボルを上書きすることは可能

    writeln(a);         // 1; このスコープのa
    writeln(.a);        // 0; グローバルなa

    {
        //ここはmainより1つ内側のスコープ

        //string a;     // グローバルでないシンボルを上書きすることはできない
        string b = "foo";

        writeln(a);     // 1
        writeln(.a);    // 0
        writeln(b);     // foo

        // string型のbの寿命はここまで
    }

    {
        //writeln(b);   // このスコープから、上のスコープのbを見ることはできない
    }

    //writeln(b);       // 外側のスコープから、内側のbは見れない
    uint b;             // 内側のbは見えないから、bをシンボルとして定義してもよい

    foo();              // グローバルスコープにあるシンボルは、ソースコードで下にあっても使える
    writeln(bar);       // 同上

    // double型のaやuint型のbの寿命はここまで
}


int bar = 12;


void foo()
{
    //writeln(b);       // 0; main関数のuint型のbも、string型のbも見えない
}
~~~~


### 左辺値(lvalue)と右辺値(rvalue)

次のプログラムがおかしいことはすぐにわかると思います。

````d
int a;

a = 12;         // OK

(a + 3) = 4;    // NG
````

変数である`a`には代入できるのに、`(a + 3)`には代入できません。
というのも、変数の評価結果は左辺値(lvalue; left value)となるからです。
左辺値というのは、「`=`の左側に置ける値」という意味で理解しても構いません。

逆に、`(a + 3)`は右辺値(rvalue)といい、`=`の左側には置くことができません。

(左辺値であったとしても代入できるとは限りません。`const`や`immutable`で型修飾されていれば代入は不可能です)


## いろいろな型(Type)

D言語のデータには型があることも前の記事で書きましたが、ここではどんな型があるかを紹介します。
また、リテラルやデフォルト初期値についても言及します。
文字型や文字列型は難しい内容が含まれているので、わからなければ読み飛ばしてもらって構いません。


### リテラル(Literal)とシンボル(Symbol)

リテラルとは、ソースコードに直接、値を記したもののことです。
プログラムが動いている間、変数は書き換えられるのに対して、リテラルはソースコードを編集しないと変更できません。
たとえば`int a = 1;`での`1`はリテラルです。

逆に、`int a = 1;`での`a`はシンボルと呼ばれます。


### デフォルト初期化値(Default Initializer; Type.init)

D言語の変数は宣言した際に初期化されます。
その際の値をデフォルト初期化値といいます。
この初期化をしてほしくない場合には、`Type iden = void;`というように`= void`とします。

~~~~d
int a;
writeln(a);         // 0; intのデフォルト初期化値は 0

writeln(int.init);  // Type.init でデフォルト初期化値を取得できる

int b = void;       // 初期化を阻止
writeln(b);         // 何が表示されるかわからない
~~~~


### void

~~~~
* void      : 値(または型)なし。
~~~~

値がない、もしくは型がないときに`void`と書きます。
前の記事でのmain関数では、`void main()`と書いていましたが、そこではmain関数の返り値が無いことを意味しています。

(厳密には、`void main()`は、プログラムが成功し正常に終了すれば`0Pを返しますが、これについてはmain関数の項で説明します。)

### 論理型(Boolean)

~~~~
* bool      : 真偽値(`true`, `false`)
~~~~

真か偽かを判別するための型です。
デフォルト初期化値は`false`です。

~~~~d
bool b;

writeln(b); // false
b = !b;
writeln(b); // true

b = true;
writeln(b); // true

b = false;
writeln(b); // false
~~~~


### 整数型(Decimal Number)

~~~~
* byte      :  8bitの符号あり(signed)な整数
* ubyte     :  8bitの符号なし(unsigned)な整数
* short     : 16bitの符号あり整数
* ushort    : 16bitの符号なし整数
* int       : 32bitの符号あり整数
* uint      : 32bitの符号なし整数
* long      : 64bitの符号あり整数
* ulong     : 64bitの符号なし整数
* cent      : 128bitの符号あり整数(将来のために名前だけ付けられてる)
* ucent     : 128bitの符号なし整数(将来のために名前だけ付けられてる)

* size_t    : ポインタ値が十分に入る大きさの符号なし整数型
              32bit環境だと32bit(uint), 64bit環境だと64bit(ulong)

* ptrdiff_t : size_tと同じ大きさの符号あり整数型
~~~~

整数型には、8bitから倍々に64bitまであります(128bit型は今は使えない)。
符号あり整数型の前に`'u'`をつけると符号なし整数型になります。

また、`size_t`や`ptrdiff_t`という変わり種の整数型もあります。
整数型は、どれも`0`で初期化され、算術演算やビット演算が可能です。

````d
int a;

writeln(a);             // 0

ulong b = -1;

writeln(b);             // 18446744073709551615
                        // -1 は int型 だが、int -> long -> ulongと暗黙に変換される。
                        // longからulongへの変換によってこのようになる。

writeln(1uL - 2uL);     // 18446744073709551615
                        // 1uL は ulong型の1なので、
                        // 上のbと同様に負の数を表せず、このようになる。

writeln(1u);            // 数値の後ろに u とつけると uint型
writeln(1U);            // 大文字で U とつけても同じ

writeln(1L);            // 大文字の L をつければ long型

writeln(1uL);           // uL や、UL は ulong型
````


### 浮動小数点型(Floating-Point Number)

~~~~
()の中の3つの数字は、(符号部bit数, 指数部bit数, 仮数部bit数)
* float     : 32bitの浮動小数点の実数(1, 8, 23)
* double    : 64bitの浮動小数点の実数(1, 11, 52)
* real      : 64bit以上(システムによって違う)の浮動小数点の実数
~~~~

浮動小数点とは、コンピュータで実数値を表す方式のことです。
演算によって小数点が動くのでこのような名前になっています。
D言語の浮動小数点数はIEEE 754という規格に沿っています。
この型は、`float`なら`float.nan`, `double`なら`double.nan`, `real`なら`real.nan`で初期化されます。

なお、real型については64bit以上という言語仕様ですが、これは最低限保証するビット数であり、例えばIntelのCPUでは79bitの精度となっています。
(x87の拡張浮動小数点数では80bit(1, 15, 64)であるものの、IEEE 754では表されない整数部の1bitを無駄に使用しているため、精度で言えば79bit(1, 15, 63)相当となります)

````d
float  f = 1.0f;        // 数値の後に f をつければ float型
double d = 1.0;         // 少数点のある数値は double型
real   r = 1.0L;        // 少数点があり、最後に L が付いていると real型

writeln(f / 0);         // inf
writeln(0.0 / 0.0);     // -nan
````


### 虚数浮動小数点型(Imaginary Floating-Point Number)

````
* ifloat    : 32bitの浮動小数点の虚数
* idouble   : 64bitの浮動小数点の虚数
* ireal     : 80bit(システムによって違う)の浮動小数点の虚数
````

プログラミング言語では珍しい、虚数を表す型です。
それぞれ、`ifloat`なら`float.nan * 1.0i`というように初期化されます。

~~~~d
ifloat f = 1.0fi;       //  i を
~~~~

### 複素浮動小数点型(Complex Floating-Point Number)

````
* cfloat    : 32bitの浮動小数点の複素数, 64bit
* cdouble   : 64bitの浮動小数点の複素数, 128bit
* creal     : 80bit(システムによって違う)の浮動小数点の複素数, 160bit
````

実部と虚部を持つ型です。これもプログラミング言語では珍しいです。
それぞれ、`cfloat`なら`float.nan + float.nan * 1.0i`という値で初期化されます。


### 文字型(Charactor)

~~~~
* char      : UTF-8でエンコードされた文字(8bit)
* wchar     : UTF-16でエンコードされた文字(16bit)
* dchar     : UTF-32でエンコードされた文字(32bit)
~~~~

D言語で文字型を使用すると、その文字はUTF-8かUTF-16, UTF-32でエンコードされていると認識されます。
もし、Unicode以外でエンコーディングされた文字を格納する場合には、`ubyte`や`ushort`, `uint`を使用するべきです(邦訳TDPL 118ページ参照)。
また、デフォルト初期化値はそれぞれ、`0xFF`, `0xFFFF`, `0x0000FFFF`です。


### 文字列型(String)

~~~~
* string    : 文字列型(immutable(char)[])
* wstring   : 文字列型(immutable(wchar)[])
* dstring   : 文字列型(immutable(dchar)[])
~~~~

こちらも文字型を同じようにUTF-8, UTF-16, UTF-32でエンコードされていると仮定されます。
ですから、Unicode以外でエンコーディングされた文字列を格納するなら、`ubyte[]`や`immutable(ubyte)[]`, `ushort[]`, `immutable(ushort)[]`, `uint[]`, `immutable(uint)[]`を使用するべきなのです。
(ですが、私はそのようなコードを見たことがありません)(要出典)

~~~~d
string  utf8  = "ほげほげ";
wstring utf16 = "ほげほげ"w;
dstring utf32 = "ほげほげ"d;

writeln(utf8);                                  // ほげほげ
writeln(utf16);                                 // ほげほげ
writeln(utf32);                                 // ほげほげ

writeln( utf8[std.utf.stride( utf8, 0) .. $]);  // げほげ
writeln(utf16[std.utf.stride(utf16, 0) .. $]);  // げほげ
writeln(utf32[1 .. $]);                         // げほげ

writeln(std.range.drop( utf8, 2));              // ほげ
writeln(std.range.drop(utf16, 2));              // ほげ
writeln(std.range.drop(utf32, 2));              // ほげ
~~~~


### 派生型(Derived Data Type)

~~~~
* T*        : T型に対するポインタ型(Pointer)
* T[]       : T型を要素とするスライス(Slice)(動的配列; Dynamic Array)
* T[N]      : T型を連続してN要素集めた型。静的配列(Static Array)
* V[K]      : K型の値に対してV型の値が1:1で対応する型。連想配列(Associative Array)
* R function(T...)
            : T...型を受け取ってR型の値を返す関数ポインタ型
* R delegate(T...)
            : T...型を受け取ってR型の値を返すデリゲート(委譲)型
~~~~

これらの型については後ほど個々に詳しく書きます。


### ユーザー定義型(User Defined Type)

~~~~
* enum      : 列挙型
* struct    : 構造体
* union     : 共用体
* class     : クラス
* interface : インターフェース
~~~~

ユーザー(プログラマ)が、いろいろな型を組み合わせて新しい型を作るための型です。
これらについては各々独立した記事を書きます。


## 式と演算子

ここからは式のお話をします。
式は、D言語での計算の一番小さな単位です。
たとえば、`1 + 2 + 3`は式ですが、この式に含まれる`1 + 2`, `1`, `2`, `3`も同様に式です。
`1`や`2`, `3`などはリテラル(Literal)と呼ばれると先ほど説明しましたね。
式は演算子などによって、より大きな式を作ります。

式は評価されると値を持ちます。
たとえば`1`ならint型の`1`、`int a = 12;`として`a + 2`の式を評価するとint型の`14`という値になります。
`a + b`の`a`と`b`の評価は同時に行われるわけではなく、`a`が先に評価され、次に`b`が評価されます。
この評価順序は演算子によって異なりますが、2項演算子であれば左が優先されます。
ちなみに、この評価順序はそれほど重要ではありませんし、クリティカルな問題にもなりません。
2項演算子は左優先ということ以外、覚えている人や知っている人は私を含めてほぼ皆無であると思います。
(a[b]という演算子は、bを評価した後にaを評価します。関数呼び出しのa(b)は逆にaを評価してbを評価します。)
(要出典, コンパイラの実装によっては異なっても良い？)

また、演算子にはそれぞれ結合規則が定められています。
たとえば、`1.0 / 2 / 5`は`(1.0 / 2) / 5`となってdouble型の`2.5`と評価されます。
もし、`1.0 / (2 / 5)`と解釈されるなら、`2 / 5`は整数である`int`型なので、`0`と評価され、結果的に`1.0 / 0`となります。
これが、評価されると`double.inf`という値になります。
つまり、演算子の結合の方向が右なのか左なのかによって式の値は異なるので、演算子ごとに結合の向きを定義しておく必要があります。

最後に、演算子には優先度という順位があります。
先に紹介した割り算の例では、式中に現れる演算子の優先順位がすべて同じであったため、結合規則に則って評価されました。
では、`1 + 4 / 2`という式があった場合にはどうすべきでしょうか？
掛け算や割り算は、足し算や引き算よりも先に計算することを小学校の算数で勉強したと思います。
D言語でも(大体のプログラミング言語でも)同じ規則が成り立ちます。
この場合には、`1 + 4`よりも先に`4 / 2`が評価されて、`1 + 2`となり、最終的に`3`と評価されます。

プログラマはこれらの評価の順序を覚えているかというと、正確に把握できている人は少ないと思います。
ですから、`1 + 4 / 2`や`1.0 / 2 / 5`などという明らかな場合はいいのですが、複雑な場合には、カッコ`()`で式をくくりましょう。
数学と同じように、`()`でくくればその中の優先順位は最も高くなります。
`(1 + 4) / 2`なら曖昧性が一切ありません。
しかし、残念ながらソースコードでは、中括弧`{}`や大括弧`[]`は、このような目的で使えません。


## 演算子と暗黙の数値型変換

数値型はたくさんありますが、それ故に異なる型との演算がよくあります。
この項では、たとえば`float + int`のような異なる数値型同士の演算の型について説明します。

数値型の演算子の規則は、簡単に言えば「大きい型や浮動小数点型に変換される可能性がある」です。
たとえば、`float + int`はどちらも`float + float`になって`float`になります。
以下に様々な例を示します。

writeTypeはよくわからないと思いますが、2つの型で22項演算してみた結果の型を出力する関数です。

````d
import std.stdio;

void writeType(T, string op, U)()
{
    writeln(typeof(mixin("T.init " ~ op ~ " U.init")).stringof);
}

void main()
{
    writeType!(   byte, "+",    byte)();    // int
    writeType!(   byte, "+",   ubyte)();    // int
    writeType!(  ubyte, "+",   ubyte)();    // int
    
    writeln();
    
    writeType!(  short, "+",   short)();    // int
    writeType!(  short, "+",  ushort)();    // int
    writeType!( ushort, "+",  ushort)();    // int

    writeln();

    writeType!(    int, "+",     int)();    //  int
    writeType!(    int, "+",    uint)();    // uint
    writeType!(   uint, "+",    uint)();    // uint

    writeln();

    writeType!(   long, "+",    long)();    //  long
    writeType!(   long, "+",   ulong)();    // ulong
    writeType!(  ulong, "+",   ulong)();    // ulong

    writeln();

    writeType!(    int, "+",    long)();    //  long
    writeType!(    int, "+",   ulong)();    // ulong
    writeType!(   uint, "+",    long)();    //  long
    writeType!(   uint, "+",   ulong)();    // ulong

    writeln();

    writeType!(  float, "+",   float)();    //  float
    writeType!(  float, "+",  ifloat)();    // cfloat
    writeType!( ifloat, "+",  ifloat)();    // ifloat

    writeln();

    writeType!(   real, "+",   float)();    //  real
    writeType!(   real, "+",  ifloat)();    // creal
    writeType!(  ireal, "+",  ifloat)();    // ireal

    writeln();

    writeType!(  float, "+",  cfloat)();    // cfloat
    writeType!( ifloat, "+",  cfloat)();    // cfloat
    writeType!( cfloat, "+",  cfloat)();    // cfloat

    writeln();

    writeType!( ifloat, "*",  ifloat)();    // float

    writeln();

    writeType!(   long, "+",   float)();    //  float
    writeType!(   long, "+",  ifloat)();    // cfloat
}
````

例をよく見ると、intより小さな整数型では、全てint型になっています。
int型以上の大きさの整数型では、より大きな型になります。
もう少しintやlongを詳しく見ると、頭に`u`がついた符号なし整数の方が強いことがわかります。

浮動小数点型では、実数型と実数型の和はもちろん実数型、実数型と虚数型の和は複素数型、虚数型同士の和は虚数型というように理に適っています。
また、複素数型に実数型や虚数型, 複素数型を足しても結果は複素数型です。
しかし、虚数型同士の積は実数型となり、数学で習ったことと一致すると思います。

整数型と浮動小数点型では、浮動小数点型のほうが強く、浮動小数点型になります。

以上のことを踏まえると、以下の様な規則に従っていることがわかります。

* 規則1: 数値型の暗黙変換のルール

1. 整数型から、より大きいサイズの整数型へは暗黙変換可能
2. 浮動小数点型から、より大きいサイズの浮動小数点型へは暗黙変換可能
3. 任意の整数型は、任意の実数浮動小数点型に暗黙変換可能

* 規則2: 演算子について、以下の規則は番号の小さいものから適応される。

1. どちらか片方が複素数型(浮動小数点型)である。
    そのうち最大の型にどちらの項も暗黙変換され、結果はその型となる。

2. どちらも虚数型(浮動小数点型)であり、積, 商の演算子である。
    そのうち最大の型にどちらの項も暗黙変換され、結果はその大きさの実数型となる。

3. どちらも虚数型(浮動小数点型)であり、和, 差の演算子である。
    そのうち最大の型にどちらの項も暗黙変換され、結果はその大きさの虚数型となる。

4. どちらか片方が虚数型(浮動小数点型)である。
    そのうち最大の型にどちらの項も暗黙変換され、結果はその大きさの複素型となる。

5. どちらか片方が浮動小数点型である。
    そのうち最大の型にどちらの項も暗黙変換され、結果はその大きさの浮動小数点型となる。

6. どちらか片方がulong型である。
    もう片方もulong型に暗黙変換され、結果もulong型。

7. どちらか片方がlong型である。
    もう片方もlong型に暗黙変換され、結果もlong型。

8. どちらか片方がuint型である。
    もう片方もuint型に暗黙変換され、結果もuint型。

9. その他の整数同士の演算
    両方ともint型に暗黙変換され、結果もint型。

規則2はややこしいかもしれませんが、複素数や虚数が式に現れなければ、5～9のみを意識すればよく、それらの基礎は規則1に従っているので理解しやすいと思います。


## 数値型に対する演算子

D言語の数値型には、大きく分けると整数型と浮動小数点型があることを説明しました。
ここでは、その数値型で使える演算子について説明して行きたいと思います。
説明で特に記述がない限り、全ての数値型で使用可能です。


### カッコ

~~~~d
int a = (1 + 2) / 1;
double d = (1.0 * 3) / 4.5;
~~~~

カッコは最も優先される演算子で、優先順位は1となっています。


### 単項プラス, 単項マイナス

~~~~d
int a = 12;

writeln(+a);    //  12
writeln(-a);    // -12

double d = 12;
writeln(+d);    //  12
writeln(-d);    // -12

cdouble c = 2 + 2i;
writeln(+c);    //  2+2i
writeln(-c);    // -2+-2i
~~~~

単項マイナス演算子は、符号を反転させるときに使用します。
単項プラス演算子は、ソースコードを見やすくするためだけにあります。
この2つの演算子は、優先順位3となっています。


### インクリメント, デクリメント

~~~~d
int a = 12;

writeln(++a);   // 13 前置インクリメント
writeln(a);     // 13

writeln(a++);   // 13 後置インクリメント
writeln(a);     // 14

writeln(--a);   // 13 前置デクリメント
writeln(a);     // 13

writeln(a--);   // 13 後置デクリメント
writeln(a);     // 12
~~~~

インクリメント(increment)とは、値を一つ増やすことです。
デクリメント(decrement)は逆に値を一つ減らします。
インクリメントもデクリメントも、左辺値(lvalue)でないと使えません。
左辺値というのはまだ説明していませんが、つまり、`++1`や`++(a + 3)`というのは出来ないということです。
理由は簡単で、そのように書いても加算された結果を格納できないからです。

インクリメントとデクリメントには、前置と後置があります。
前置の方を先に説明すると、「値を`1`だけ{増やして/減らして}から、評価する」となります。
つまり、`++a`は「`a`の値を`1`増やしてから、`a`を評価する」ということです。

後置インクリメントや後置デクリメントは、「`a`を評価した値を記憶しつつ、`a`の値を`1`だけ増やし、先ほど記憶した値を結果とする」という演算子です。

前置形式と後置形式で決定的に違うのがもう一つあります。
それは、「前置形式は左辺値を返すのに対して、後置形式は右辺値を返す」ことです。
左辺値は「`=`の左側に置ける値」で、右辺値は「`=`の右側に置ける値」でした。
インクリメントとデクリメントは左辺値に対して作用するので、後置形式の結果をインクリメントやデクリメントすることはできません。
逆に前置形式の結果はインクリメント,デクリメント可能です。

````d
float a = 1;

writeln(++(++a));   // OK
writeln((++a)++);   // OK
++a = 12;           // OK

writeln((a++)++);   // NG; Error: a++ is not an lvalue
writeln(++(a++));   // NG; Error: a++ is not an lvalue
a++ = 20;           // NG; Error: a++ is not an lvalue
````

ちなみに、前置形式と後置形式では後置形式の方が優先順位が高くなっています。
前置形式は優先順位3であるのに対して、後置形式は2です。

````d
cfloat c = 1 + 1i;

writeln(++c);       // 2+1i

writeln(++c++);     // NG; Error: c++ is not an lvalue
                    // ++(c++)と解釈されるため

writeln((++c)++);   // OK
````


### 否定

~~~~d
bool b = true;

writeln(!b);    // false
writeln(!!b);   // true

int a = 12;
writeln(!a);    // false
writeln(!!a);   // true
~~~~

3

### 補数

3

### 加算, 減算

加算と減算は特に言うことは無いと思います。
加算の演算子`+`と、減算の演算子`-`の優先順位と結合規則は同じで、優先順位6の左→右への結合規則です。
2項演算子なので、左辺を先に評価します。

~~~~d
int a = 1,
    b = 2;

writeln(a + b);     // 3
writeln(a - b);     // -1

int c = 3;

writeln(a + b + c); // (a + b) + c と解釈
writeln(a - b + c); // (a - b) + c と解釈
~~~~


### 乗算, 除算

乗算や除算は優先順位が5と、加算や減算よりも優先されるようになっています。
結合規則は、左→右です。
また、この2つも2項演算子なので、左辺を先に評価します。

~~~~d
int a = 1,
    b = 2;

writeln(a * b);     // 2
writeln(a / b);     // 0

int c = 3;

writeln(a * b * c); // (a * b) * c と解釈
writeln(a / b * c); // (a / b) * c と解釈
~~~~


### 剰余

~~~~d
writeln(10 % 3);    // 1; 10 / 3 = 3 .. 1
writeln(12 % 3);    // 0; 12 / 3 = 3 .. 0

writeln(-10 %  3);  // -1; -10 /  3 = -3 .. -1
writeln(-10 % -3);  // -1; -10 / -3 =  3 .. -1
writeln( 10 % -3);  //  1;  10 / -3 = -3 ..  1

writeln(11.6 % 3);  // 2.6; 11.6 / 3   = 3 .. 2.6
writeln(11.6 % 3.5);// 1.1; 11.6 / 3.5 = 3 .. 1.1

writeln(3 % 0.6);   // 0.6(誤差があるため)
~~~~

剰余演算子は、割り算での余りに相当します。
最後の例のように、浮動小数点数の演算では丸め誤差が存在するため、思った答えと違うものが出る可能性があります。
ほとんど整数でしか使用しないので気にはなりませんが、浮動小数点に対して使用する場合には注意が必要です。

優先順位は積や商と同じ5で、結合規則も同じ右→左です。


### 累乗

~~~~d
writeln()
~~~~

### ビット演算

10

### シフト演算

7

### 同値テスト(==), 非同値テスト(!=)

9

### 比較

9


### 論理演算子

and 11
or 12
条件 13

### 代入演算子, 複合代入演算子

14


### コンマ演算子

15


### 条件演算子


## おわりに


## キーワード

* 式(Expression)
* 文(Statement)
* 宣言(Declaration)
* 変数(Variable)
* スコープ(Scope)
* シンボル(Symbol)
* グローバルスコープ(Global Scope)
* 値(Value)
* 型(Type)
* リテラル(Literal)
* シンボル(Symbol)
* デフォルト初期化値(デフォルト値, デフォルト初期化子; Default Initializer)
* void
* 論理型(Boolean); `bool, true, false`
* 整数型(Decimal Number); `byte, ubyte, short, ushort, int, uint, long, ulong, cent, ucent, size_t, ptrdiff_t`
* 浮動小数点型(Floating-Point Number); `float, double, real`
* 虚数浮動小数点型(Imaginary Floating Point); `ifloat, idouble, ireal`
* 複素数浮動小数点型(Complex Floating-Point Number); `cfloat, cdouble, creal`
* 文字型(Charactor); `char, wchar, dchar`
* 文字列型(String); `string, wstring, dstring`
* 派生型(Derived Data Type); 
* ユーザー定義型(User Defined Type); `enum, struct, union, class, interface`
* 評価(Evaluation)
* 暗黙の型変換(Implicit)
* 演算子(Operator)
* 演算子の優先順位(Priority of Operators, Order of Operators)
* 演算子の結合規則(Operator Associativity)